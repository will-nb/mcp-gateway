#!/bin/bash

# 脚本出错时立即退出
set -e

# 颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# 项目根目录
ROOT_DIR=$(git rev-parse --show-toplevel 2>/dev/null || echo "$(cd "$(dirname "$0")/.." && pwd)")

# --- Git hooks management ---

hooks_install() {
  echo -e "${YELLOW}🔧 安装 Git hooks (.githooks) 并设置执行权限...${NC}"
  local hooks_dir="$ROOT_DIR/.githooks"
  mkdir -p "$hooks_dir"
  chmod +x "$ROOT_DIR/.githooks/pre-commit" 2>/dev/null || true
  chmod +x "$ROOT_DIR/.githooks/pre-push" 2>/dev/null || true
  git config core.hooksPath .githooks
  echo -e "${GREEN}✅ hooks 安装完成。将自动在 commit/push 时触发。${NC}"
}

hooks_run_pre_commit() {
  echo -e "${YELLOW}▶ 运行 pre-commit...${NC}"
  bash "$ROOT_DIR/.githooks/pre-commit"
}

hooks_run_pre_push() {
  echo -e "${YELLOW}▶ 运行 pre-push...${NC}"
  bash "$ROOT_DIR/.githooks/pre-push"
}

# --- Git: 本地分支清理（housekeeping） ---

git_housekeeping() {
  local DRY_RUN=false
  local VERBOSE=false
  local SHOW_COMMANDS=false

  shift 1
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run|-d) DRY_RUN=true; shift;;
      --verbose|-v) VERBOSE=true; shift;;
      --show-commands) SHOW_COMMANDS=true; shift;;
      *)
        echo -e "${RED}错误: 未知选项 '$1'${NC}"
        echo "用法: scripts/anz git:housekeeping [--dry-run|-d] [--verbose|-v] [--show-commands]"
        return 1;;
    esac
  done

  run() {
    local cmd="$1"
    [[ "$SHOW_COMMANDS" == true ]] && echo -e "$ ${cmd}"
    set +e
    local output
    output=$(eval "$cmd" 2>&1)
    local code=$?
    set -e
    echo "$output"
    return $code
  }

  step() {
    local title="$1"; local cmd="$2"; local allow_fail=${3:-false}
    echo -e "▶ ${title}"
    local output; output=$(run "$cmd"); local code=$?
    if [[ $code -eq 0 ]]; then
      echo -e "${GREEN}✓ ${title}${NC}"
      [[ -n "$output" && "$VERBOSE" == true ]] && echo "$output"
      return 0
    fi
    if [[ "$allow_fail" == true ]]; then
      echo -e "${YELLOW}! ${title} (继续)：${NC}$(echo "$output" | tail -n 1)"
      [[ -n "$output" && "$VERBOSE" == true ]] && echo "$output"
      return $code
    fi
    echo -e "${RED}✗ ${title}：$(echo "$output" | tail -n 1)${NC}"
    return $code
  }

  echo -e "\n${GREEN}=============== Git 本地分支清理 (housekeeping) ===============${NC}"

  step "抓取远端并修剪无效引用" "git fetch origin --prune" || return $?

  if ! step "切换到 develop 分支" "git switch develop" true; then return $?; fi
  if ! git rev-parse --verify develop >/dev/null 2>&1; then
    step "创建本地 develop 并跟踪 origin/develop" "git checkout -t origin/develop" || return $?
  fi

  set +e
  pull_out=$(run "git pull --ff-only"); pull_code=$?
  set -e
  if [[ $pull_code -eq 0 ]]; then
    echo -e "${GREEN}✓ 拉取 develop 最新提交 (fast-forward)${NC}"
    [[ -n "$pull_out" && "$VERBOSE" == true ]] && echo "$pull_out"
  else
    echo -e "${RED}✗ 拉取 develop 失败（非快进或网络问题）：$(echo "$pull_out" | tail -n 1)${NC}"
    echo -e "${YELLOW}提示：请先使本地 develop 与远端保持快进关系（例如 rebase 或 reset），再重试。${NC}"
    return $pull_code
  fi

  branches=$(run "git for-each-ref --format='%(refname:short)' refs/heads/*" | sed '/^$/d')
  echo -e "▶ 枚举本地分支"
  if [[ -z "$branches" ]]; then
    echo -e "${YELLOW}没有找到本地分支。${NC}"; return 0
  fi
  local count; count=$(echo "$branches" | wc -l | tr -d ' ')
  echo -e "发现本地分支 ${count} 个：$(echo "$branches" | paste -sd ', ' -)"

  rev_develop=$(run "git rev-parse develop" | tail -n 1)
  PROTECTED=("main" "develop"); CANDIDATES=()
  while IFS= read -r br; do
    [[ -z "$br" ]] && continue
    for p in "${PROTECTED[@]}"; do [[ "$br" == "$p" ]] && echo -e "- ${br}: 跳过（受保护分支）" && continue 2; done
    set +e; run "git merge-base --is-ancestor '$br' develop" >/dev/null; is_ancestor_code=$?; set -e
    if [[ $is_ancestor_code -ne 0 ]]; then echo -e "- ${br}: 跳过（未完全合入 develop，可能分叉或领先）"; continue; fi
    rev_br=$(run "git rev-parse '$br'" | tail -n 1)
    if [[ "$rev_br" == "$rev_develop" ]]; then echo -e "- ${br}: 跳过（与 develop 指向同一提交，非严格落后）"; continue; fi
    echo -e "- ${br}: 计划删除（已被 develop 覆盖且严格落后）"; CANDIDATES+=("$br")
  done <<< "$branches"

  if [[ ${#CANDIDATES[@]} -eq 0 ]]; then echo -e "${YELLOW}没有可删除的本地分支。${NC}"; return 0; fi
  for br in "${CANDIDATES[@]}"; do
    if [[ "$DRY_RUN" == true ]]; then echo -e "[dry-run] 将删除本地分支：${br}"; continue; fi
    set +e; del_out=$(run "git branch -d '$br'"); del_code=$?; set -e
    if [[ $del_code -eq 0 ]]; then echo -e "${GREEN}✓ 已删除本地分支：${br}${NC}"; [[ -n "$del_out" && "$VERBOSE" == true ]] && echo "$del_out"; else echo -e "${RED}✗ 删除失败：${br} -> $(echo "$del_out" | tail -n 1)${NC}"; fi
  done
}

# --- 命令分发 ---
COMMAND="$1"
case "$COMMAND" in
  git:housekeeping)
    git_housekeeping "$@" ;;
  hooks:install)
    hooks_install ;;
  hooks:run-pre-commit)
    hooks_run_pre_commit ;;
  hooks:run-pre-push)
    hooks_run_pre_push ;;
  *)
    echo -e "${RED}错误: 未知命令 '$COMMAND'${NC}"
    echo "可用命令:"
    echo "  git:housekeeping   - 清理已被 develop 包含且严格落后的本地分支（支持 --dry-run/-d, --verbose/-v, --show-commands）"
    echo ""
    echo "Git Hooks:"
    echo "  hooks:install       - 安装本地 Git hooks (pre-commit, pre-push)"
    echo "  hooks:run-pre-commit - 手动执行 pre-commit 钩子"
    echo "  hooks:run-pre-push   - 手动执行 pre-push 钩子"
    exit 1 ;;
esac
