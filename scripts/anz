#!/bin/bash

# 脚本出错时立即退出
set -e

# 颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# 项目根目录
ROOT_DIR=$(git rev-parse --show-toplevel 2>/dev/null || echo "$(cd "$(dirname "$0")/.." && pwd)")
ENV_FILE="$ROOT_DIR/.env"

# --- Docker/服务检测 & 测试辅助 ---

check_docker_service() {
  local service_name="$1"
  echo -e "${YELLOW}🔎 正在检查 Docker 服务 '$service_name' 是否正在运行...${NC}"
  if ! docker-compose ps -q "$service_name" | grep -q .; then
    echo -e "${RED}❌ 错误: Docker 服务 '$service_name' 未运行。${NC}"
    echo -e "${YELLOW}🤔 请先使用 'docker-compose up -d' 启动所需服务。${NC}"
    exit 1
  fi
  echo -e "${GREEN}✅ 服务 '$service_name' 正在运行。${NC}"
}

run_unit_tests() {
  echo -e "\n${GREEN}=============== 运行单元测试 ===============${NC}"
  check_docker_service "app"
  echo -e "${YELLOW}🧪 正在容器内运行 pytest tests (无特定目录则运行全量)...${NC}"
  docker-compose exec -T app pytest tests
}

run_integration_tests() {
  echo -e "\n${GREEN}=============== 运行集成测试 ===============${NC}"
  check_docker_service "app"
  if docker-compose exec -T app bash -lc 'test -d tests/integration'; then
    echo -e "${YELLOW}🧪 正在容器内运行 pytest tests/integration...${NC}"
    docker-compose exec -T app pytest tests/integration
  else
    echo -e "${YELLOW}⚠️ 未发现 tests/integration 目录，退回运行全量 tests...${NC}"
    docker-compose exec -T app pytest tests
  fi
}

run_api_tests() {
  echo -e "\n${GREEN}=============== 运行 API 测试 ===============${NC}"
  check_docker_service "app"
  if docker-compose exec -T app bash -lc 'test -d tests/api'; then
    docker-compose exec -T app pytest tests/api
  else
    echo -e "${YELLOW}⚠️ 未发现 tests/api 目录，退回运行全量 tests...${NC}"
    docker-compose exec -T app pytest tests
  fi
}

run_remote_smoke_points() {
  echo -e "\n${GREEN}=============== 运行远程 API 冒烟测试（按需） ===============${NC}"
  check_docker_service "app"
  TARGET_URL=${API_BASE_URL:-http://localhost:8081}
  echo -e "使用 API_BASE_URL=$TARGET_URL"
  if docker-compose exec -T app bash -lc 'test -f tests/api/remote/test_points.py'; then
    docker-compose exec -T app pytest tests/api/remote/test_points.py --api-base-url "$TARGET_URL"
  else
    echo -e "${YELLOW}⚠️ 未发现 tests/api/remote/test_points.py，跳过。${NC}"
  fi
}

set_middleware_status() {
  local status="$1"
  if [[ -f "$ENV_FILE" ]]; then
    echo -e "${YELLOW}🔧 配置 .env, 设置 RATE_LIMIT_ENABLED=$status...${NC}"
    sed -i.bak "s/^RATE_LIMIT_ENABLED=.*/RATE_LIMIT_ENABLED=$status/" "$ENV_FILE" || true
    rm -f "${ENV_FILE}.bak" || true
  fi
}

run_middleware_tests() {
  echo -e "\n${GREEN}=============== 运行中间件行为测试 ===============${NC}"
  check_docker_service "app"
  local original_status
  original_status=$(grep "^RATE_LIMIT_ENABLED=" "$ENV_FILE" 2>/dev/null | cut -d'=' -f2)
  echo -e "${YELLOW}📝 当前限流状态: ${original_status:-<未设置>} ${NC}"
  trap 'echo -e "${YELLOW}🧹 恢复限流状态...${NC}"; set_middleware_status "${original_status:-false}"; docker-compose restart app >/dev/null 2>&1 || true; echo -e "${GREEN}✅ 环境已恢复。${NC}"' EXIT
  echo -e "${YELLOW}🔧 启用限流功能进行测试...${NC}"; set_middleware_status true
  echo -e "${YELLOW}🔄 重启容器以应用配置...${NC}"; docker-compose down; docker-compose up -d
  echo -e "${YELLOW}⏳ 等待服务启动...${NC}"; sleep 10
  if docker-compose exec -T app bash -lc 'pytest -m middleware tests/api'; then
    echo -e "${GREEN}✅ 中间件测试通过！${NC}"
  else
    echo -e "${RED}❌ 中间件测试失败。${NC}"; exit 1
  fi
}


# --- Git hooks management ---

hooks_install() {
  echo -e "${YELLOW}🔧 安装 Git hooks (.githooks) 并设置执行权限...${NC}"
  local hooks_dir="$ROOT_DIR/.githooks"
  mkdir -p "$hooks_dir"
  chmod +x "$ROOT_DIR/.githooks/pre-commit" 2>/dev/null || true
  chmod +x "$ROOT_DIR/.githooks/pre-push" 2>/dev/null || true
  git config core.hooksPath .githooks
  echo -e "${GREEN}✅ hooks 安装完成。将自动在 commit/push 时触发。${NC}"
}

hooks_run_pre_commit() {
  echo -e "${YELLOW}▶ 运行 pre-commit...${NC}"
  bash "$ROOT_DIR/.githooks/pre-commit"
}

hooks_run_pre_push() {
  echo -e "${YELLOW}▶ 运行 pre-push...${NC}"
  bash "$ROOT_DIR/.githooks/pre-push"
}

# --- Git: 本地分支清理（housekeeping） ---

git_housekeeping() {
  local DRY_RUN=false
  local VERBOSE=false
  local SHOW_COMMANDS=false

  shift 1
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run|-d) DRY_RUN=true; shift;;
      --verbose|-v) VERBOSE=true; shift;;
      --show-commands) SHOW_COMMANDS=true; shift;;
      *)
        echo -e "${RED}错误: 未知选项 '$1'${NC}"
        echo "用法: scripts/anz git:housekeeping [--dry-run|-d] [--verbose|-v] [--show-commands]"
        return 1;;
    esac
  done

  run() {
    local cmd="$1"
    [[ "$SHOW_COMMANDS" == true ]] && echo -e "$ ${cmd}"
    set +e
    local output
    output=$(eval "$cmd" 2>&1)
    local code=$?
    set -e
    echo "$output"
    return $code
  }

  step() {
    local title="$1"; local cmd="$2"; local allow_fail=${3:-false}
    echo -e "▶ ${title}"
    local output; output=$(run "$cmd"); local code=$?
    if [[ $code -eq 0 ]]; then
      echo -e "${GREEN}✓ ${title}${NC}"
      [[ -n "$output" && "$VERBOSE" == true ]] && echo "$output"
      return 0
    fi
    if [[ "$allow_fail" == true ]]; then
      echo -e "${YELLOW}! ${title} (继续)：${NC}$(echo "$output" | tail -n 1)"
      [[ -n "$output" && "$VERBOSE" == true ]] && echo "$output"
      return $code
    fi
    echo -e "${RED}✗ ${title}：$(echo "$output" | tail -n 1)${NC}"
    return $code
  }

  echo -e "\n${GREEN}=============== Git 本地分支清理 (housekeeping) ===============${NC}"

  step "抓取远端并修剪无效引用" "git fetch origin --prune" || return $?

  if ! step "切换到 develop 分支" "git switch develop" true; then return $?; fi
  if ! git rev-parse --verify develop >/dev/null 2>&1; then
    step "创建本地 develop 并跟踪 origin/develop" "git checkout -t origin/develop" || return $?
  fi

  set +e
  pull_out=$(run "git pull --ff-only"); pull_code=$?
  set -e
  if [[ $pull_code -eq 0 ]]; then
    echo -e "${GREEN}✓ 拉取 develop 最新提交 (fast-forward)${NC}"
    [[ -n "$pull_out" && "$VERBOSE" == true ]] && echo "$pull_out"
  else
    echo -e "${RED}✗ 拉取 develop 失败（非快进或网络问题）：$(echo "$pull_out" | tail -n 1)${NC}"
    echo -e "${YELLOW}提示：请先使本地 develop 与远端保持快进关系（例如 rebase 或 reset），再重试。${NC}"
    return $pull_code
  fi

  branches=$(run "git for-each-ref --format='%(refname:short)' refs/heads/*" | sed '/^$/d')
  echo -e "▶ 枚举本地分支"
  if [[ -z "$branches" ]]; then
    echo -e "${YELLOW}没有找到本地分支。${NC}"; return 0
  fi
  local count; count=$(echo "$branches" | wc -l | tr -d ' ')
  echo -e "发现本地分支 ${count} 个：$(echo "$branches" | paste -sd ', ' -)"

  rev_develop=$(run "git rev-parse develop" | tail -n 1)
  PROTECTED=("main" "develop"); CANDIDATES=()
  while IFS= read -r br; do
    [[ -z "$br" ]] && continue
    for p in "${PROTECTED[@]}"; do [[ "$br" == "$p" ]] && echo -e "- ${br}: 跳过（受保护分支）" && continue 2; done
    set +e; run "git merge-base --is-ancestor '$br' develop" >/dev/null; is_ancestor_code=$?; set -e
    if [[ $is_ancestor_code -ne 0 ]]; then echo -e "- ${br}: 跳过（未完全合入 develop，可能分叉或领先）"; continue; fi
    rev_br=$(run "git rev-parse '$br'" | tail -n 1)
    if [[ "$rev_br" == "$rev_develop" ]]; then echo -e "- ${br}: 跳过（与 develop 指向同一提交，非严格落后）"; continue; fi
    echo -e "- ${br}: 计划删除（已被 develop 覆盖且严格落后）"; CANDIDATES+=("$br")
  done <<< "$branches"

  if [[ ${#CANDIDATES[@]} -eq 0 ]]; then echo -e "${YELLOW}没有可删除的本地分支。${NC}"; return 0; fi
  for br in "${CANDIDATES[@]}"; do
    if [[ "$DRY_RUN" == true ]]; then echo -e "[dry-run] 将删除本地分支：${br}"; continue; fi
    set +e; del_out=$(run "git branch -d '$br'"); del_code=$?; set -e
    if [[ $del_code -eq 0 ]]; then echo -e "${GREEN}✓ 已删除本地分支：${br}${NC}"; [[ -n "$del_out" && "$VERBOSE" == true ]] && echo "$del_out"; else echo -e "${RED}✗ 删除失败：${br} -> $(echo "$del_out" | tail -n 1)${NC}"; fi
  done
}

# --- 命令分发 ---
COMMAND="$1"
case "$COMMAND" in
  test:unit)
    run_unit_tests ;;
  test:integration)
    run_integration_tests ;;
  test:api)
    run_api_tests ;;
  test:remote:smoke)
    run_remote_smoke_points ;;
  git:housekeeping)
    git_housekeeping "$@" ;;
  hooks:install)
    hooks_install ;;
  hooks:run-pre-commit)
    hooks_run_pre_commit ;;
  hooks:run-pre-push)
    hooks_run_pre_push ;;
  *)
    echo -e "${RED}错误: 未知命令 '$COMMAND'${NC}"
    echo "可用命令:"
    echo "  test:unit         - 运行最快速的单元测试 (无外部依赖)"
    echo "  test:integration  - 运行集成测试 (若无目录则运行全量 tests)"
    echo "  test:api          - 运行 API 相关测试 (若无目录则运行全量 tests)"
    echo "  test:remote:smoke - 运行远程冒烟（按需），支持 API_BASE_URL 覆盖目标"
    echo "  git:housekeeping   - 清理已被 develop 包含且严格落后的本地分支（支持 --dry-run/-d, --verbose/-v, --show-commands）"
    echo ""
    echo "Git Hooks:"
    echo "  hooks:install       - 安装本地 Git hooks (pre-commit, pre-push)"
    echo "  hooks:run-pre-commit - 手动执行 pre-commit 钩子"
    echo "  hooks:run-pre-push   - 手动执行 pre-push 钩子"
    exit 1 ;;
esac
