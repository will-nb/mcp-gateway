#!/bin/bash

# è„šæœ¬å‡ºé”™æ—¶ç«‹å³é€€å‡º
set -e

# é¢œè‰²
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# é¡¹ç›®æ ¹ç›®å½•
ROOT_DIR=$(git rev-parse --show-toplevel 2>/dev/null || echo "$(cd "$(dirname "$0")/.." && pwd)")

# --- Git hooks management ---

hooks_install() {
  echo -e "${YELLOW}ğŸ”§ å®‰è£… Git hooks (.githooks) å¹¶è®¾ç½®æ‰§è¡Œæƒé™...${NC}"
  local hooks_dir="$ROOT_DIR/.githooks"
  mkdir -p "$hooks_dir"
  chmod +x "$ROOT_DIR/.githooks/pre-commit" 2>/dev/null || true
  chmod +x "$ROOT_DIR/.githooks/pre-push" 2>/dev/null || true
  git config core.hooksPath .githooks
  echo -e "${GREEN}âœ… hooks å®‰è£…å®Œæˆã€‚å°†è‡ªåŠ¨åœ¨ commit/push æ—¶è§¦å‘ã€‚${NC}"
}

hooks_run_pre_commit() {
  echo -e "${YELLOW}â–¶ è¿è¡Œ pre-commit...${NC}"
  bash "$ROOT_DIR/.githooks/pre-commit"
}

hooks_run_pre_push() {
  echo -e "${YELLOW}â–¶ è¿è¡Œ pre-push...${NC}"
  bash "$ROOT_DIR/.githooks/pre-push"
}

# --- Git: æœ¬åœ°åˆ†æ”¯æ¸…ç†ï¼ˆhousekeepingï¼‰ ---

git_housekeeping() {
  local DRY_RUN=false
  local VERBOSE=false
  local SHOW_COMMANDS=false

  shift 1
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run|-d) DRY_RUN=true; shift;;
      --verbose|-v) VERBOSE=true; shift;;
      --show-commands) SHOW_COMMANDS=true; shift;;
      *)
        echo -e "${RED}é”™è¯¯: æœªçŸ¥é€‰é¡¹ '$1'${NC}"
        echo "ç”¨æ³•: scripts/anz git:housekeeping [--dry-run|-d] [--verbose|-v] [--show-commands]"
        return 1;;
    esac
  done

  run() {
    local cmd="$1"
    [[ "$SHOW_COMMANDS" == true ]] && echo -e "$ ${cmd}"
    set +e
    local output
    output=$(eval "$cmd" 2>&1)
    local code=$?
    set -e
    echo "$output"
    return $code
  }

  step() {
    local title="$1"; local cmd="$2"; local allow_fail=${3:-false}
    echo -e "â–¶ ${title}"
    local output; output=$(run "$cmd"); local code=$?
    if [[ $code -eq 0 ]]; then
      echo -e "${GREEN}âœ“ ${title}${NC}"
      [[ -n "$output" && "$VERBOSE" == true ]] && echo "$output"
      return 0
    fi
    if [[ "$allow_fail" == true ]]; then
      echo -e "${YELLOW}! ${title} (ç»§ç»­)ï¼š${NC}$(echo "$output" | tail -n 1)"
      [[ -n "$output" && "$VERBOSE" == true ]] && echo "$output"
      return $code
    fi
    echo -e "${RED}âœ— ${title}ï¼š$(echo "$output" | tail -n 1)${NC}"
    return $code
  }

  echo -e "\n${GREEN}=============== Git æœ¬åœ°åˆ†æ”¯æ¸…ç† (housekeeping) ===============${NC}"

  step "æŠ“å–è¿œç«¯å¹¶ä¿®å‰ªæ— æ•ˆå¼•ç”¨" "git fetch origin --prune" || return $?

  if ! step "åˆ‡æ¢åˆ° develop åˆ†æ”¯" "git switch develop" true; then return $?; fi
  if ! git rev-parse --verify develop >/dev/null 2>&1; then
    step "åˆ›å»ºæœ¬åœ° develop å¹¶è·Ÿè¸ª origin/develop" "git checkout -t origin/develop" || return $?
  fi

  set +e
  pull_out=$(run "git pull --ff-only"); pull_code=$?
  set -e
  if [[ $pull_code -eq 0 ]]; then
    echo -e "${GREEN}âœ“ æ‹‰å– develop æœ€æ–°æäº¤ (fast-forward)${NC}"
    [[ -n "$pull_out" && "$VERBOSE" == true ]] && echo "$pull_out"
  else
    echo -e "${RED}âœ— æ‹‰å– develop å¤±è´¥ï¼ˆéå¿«è¿›æˆ–ç½‘ç»œé—®é¢˜ï¼‰ï¼š$(echo "$pull_out" | tail -n 1)${NC}"
    echo -e "${YELLOW}æç¤ºï¼šè¯·å…ˆä½¿æœ¬åœ° develop ä¸è¿œç«¯ä¿æŒå¿«è¿›å…³ç³»ï¼ˆä¾‹å¦‚ rebase æˆ– resetï¼‰ï¼Œå†é‡è¯•ã€‚${NC}"
    return $pull_code
  fi

  branches=$(run "git for-each-ref --format='%(refname:short)' refs/heads/*" | sed '/^$/d')
  echo -e "â–¶ æšä¸¾æœ¬åœ°åˆ†æ”¯"
  if [[ -z "$branches" ]]; then
    echo -e "${YELLOW}æ²¡æœ‰æ‰¾åˆ°æœ¬åœ°åˆ†æ”¯ã€‚${NC}"; return 0
  fi
  local count; count=$(echo "$branches" | wc -l | tr -d ' ')
  echo -e "å‘ç°æœ¬åœ°åˆ†æ”¯ ${count} ä¸ªï¼š$(echo "$branches" | paste -sd ', ' -)"

  rev_develop=$(run "git rev-parse develop" | tail -n 1)
  PROTECTED=("main" "develop"); CANDIDATES=()
  while IFS= read -r br; do
    [[ -z "$br" ]] && continue
    for p in "${PROTECTED[@]}"; do [[ "$br" == "$p" ]] && echo -e "- ${br}: è·³è¿‡ï¼ˆå—ä¿æŠ¤åˆ†æ”¯ï¼‰" && continue 2; done
    set +e; run "git merge-base --is-ancestor '$br' develop" >/dev/null; is_ancestor_code=$?; set -e
    if [[ $is_ancestor_code -ne 0 ]]; then echo -e "- ${br}: è·³è¿‡ï¼ˆæœªå®Œå…¨åˆå…¥ developï¼Œå¯èƒ½åˆ†å‰æˆ–é¢†å…ˆï¼‰"; continue; fi
    rev_br=$(run "git rev-parse '$br'" | tail -n 1)
    if [[ "$rev_br" == "$rev_develop" ]]; then echo -e "- ${br}: è·³è¿‡ï¼ˆä¸ develop æŒ‡å‘åŒä¸€æäº¤ï¼Œéä¸¥æ ¼è½åï¼‰"; continue; fi
    echo -e "- ${br}: è®¡åˆ’åˆ é™¤ï¼ˆå·²è¢« develop è¦†ç›–ä¸”ä¸¥æ ¼è½åï¼‰"; CANDIDATES+=("$br")
  done <<< "$branches"

  if [[ ${#CANDIDATES[@]} -eq 0 ]]; then echo -e "${YELLOW}æ²¡æœ‰å¯åˆ é™¤çš„æœ¬åœ°åˆ†æ”¯ã€‚${NC}"; return 0; fi
  for br in "${CANDIDATES[@]}"; do
    if [[ "$DRY_RUN" == true ]]; then echo -e "[dry-run] å°†åˆ é™¤æœ¬åœ°åˆ†æ”¯ï¼š${br}"; continue; fi
    set +e; del_out=$(run "git branch -d '$br'"); del_code=$?; set -e
    if [[ $del_code -eq 0 ]]; then echo -e "${GREEN}âœ“ å·²åˆ é™¤æœ¬åœ°åˆ†æ”¯ï¼š${br}${NC}"; [[ -n "$del_out" && "$VERBOSE" == true ]] && echo "$del_out"; else echo -e "${RED}âœ— åˆ é™¤å¤±è´¥ï¼š${br} -> $(echo "$del_out" | tail -n 1)${NC}"; fi
  done
}

# --- å‘½ä»¤åˆ†å‘ ---
COMMAND="$1"
case "$COMMAND" in
  git:housekeeping)
    git_housekeeping "$@" ;;
  hooks:install)
    hooks_install ;;
  hooks:run-pre-commit)
    hooks_run_pre_commit ;;
  hooks:run-pre-push)
    hooks_run_pre_push ;;
  *)
    echo -e "${RED}é”™è¯¯: æœªçŸ¥å‘½ä»¤ '$COMMAND'${NC}"
    echo "å¯ç”¨å‘½ä»¤:"
    echo "  git:housekeeping   - æ¸…ç†å·²è¢« develop åŒ…å«ä¸”ä¸¥æ ¼è½åçš„æœ¬åœ°åˆ†æ”¯ï¼ˆæ”¯æŒ --dry-run/-d, --verbose/-v, --show-commandsï¼‰"
    echo ""
    echo "Git Hooks:"
    echo "  hooks:install       - å®‰è£…æœ¬åœ° Git hooks (pre-commit, pre-push)"
    echo "  hooks:run-pre-commit - æ‰‹åŠ¨æ‰§è¡Œ pre-commit é’©å­"
    echo "  hooks:run-pre-push   - æ‰‹åŠ¨æ‰§è¡Œ pre-push é’©å­"
    exit 1 ;;
esac
